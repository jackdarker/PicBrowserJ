/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package picbrowserj;

import java.io.File;
import java.io.IOException;
import java.nio.file.DirectoryIteratorException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Observer;
import java.util.Observable;
import javax.swing.SwingUtilities;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeSelectionModel;
/**
 *
 * @author homeadmin
 */
public class FrmBrowser extends javax.swing.JInternalFrame 
    implements Observer,TreeSelectionListener {

    /**
     * Creates new form FrmBrowser
     */
    public FrmBrowser() {
        super("Document #" ,
          true, //resizable
          true, //closable
          true, //maximizable
          true);//iconifiablesuper("Document #" + (++openFrameCount),
          initComponents();
           jTree1.getSelectionModel().setSelectionMode
            (TreeSelectionModel.SINGLE_TREE_SELECTION);
            //Listen for when the selection changes.
            jTree1.addTreeSelectionListener(this);
          SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
               
                updatePicList();
            }
          });
    }

    @Override
    public void valueChanged(TreeSelectionEvent e) {
        Object _Obj = e.getNewLeadSelectionPath().getLastPathComponent();
        DefaultMutableTreeNode _Node = DefaultMutableTreeNode.class.cast(_Obj);
        FileNode userObject = FileNode.class.cast(_Node.getUserObject());
        String _Path= userObject.getFile().getAbsolutePath();
        //_path = e.newLeadSelectionPath.lastPathComponent.userObject.file.path;
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jToolBar1 = new javax.swing.JToolBar();
        jComboBox1 = new javax.swing.JComboBox<>();
        jSplitPane1 = new javax.swing.JSplitPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList<>();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTree1 = new javax.swing.JTree();

        jToolBar1.setFloatable(false);
        jToolBar1.setRollover(true);

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        jToolBar1.add(jComboBox1);

        jSplitPane1.setDividerLocation(200);
        jSplitPane1.setResizeWeight(0.5);

        jList1.setModel(new javax.swing.AbstractListModel<String>() {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public String getElementAt(int i) { return strings[i]; }
        });
        jList1.setDragEnabled(true);
        jScrollPane1.setViewportView(jList1);

        jSplitPane1.setRightComponent(jScrollPane1);

        jTree1.setShowsRootHandles(true);
        jTree1.setToggleClickCount(1);
        jTree1.addTreeSelectionListener(new javax.swing.event.TreeSelectionListener() {
            public void valueChanged(javax.swing.event.TreeSelectionEvent evt) {
                jTree1ValueChanged(evt);
            }
        });
        jScrollPane2.setViewportView(jTree1);

        jSplitPane1.setLeftComponent(jScrollPane2);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 616, Short.MAX_VALUE))
            .addComponent(jSplitPane1)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 349, Short.MAX_VALUE)
                .addGap(0, 25, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jTree1ValueChanged(javax.swing.event.TreeSelectionEvent evt) {//GEN-FIRST:event_jTree1ValueChanged

    }//GEN-LAST:event_jTree1ValueChanged
    
    @Override
   public void update(Observable obs, Object obj)
   {
   }
   public void registerToObserver(SrvPicManager obs) {
       obs.addObserver(this);
   } 
   private void updatePicList() {
       Path dir = Paths.get("D:/temp/artists");
       File fileRoot = new File("D:/temp/artists");
        root = new DefaultMutableTreeNode(new FileNode(fileRoot));
        treeModel = new DefaultTreeModel(root);
        jTree1.setModel(treeModel);
        CreateChildNodes ccn = 
                new CreateChildNodes(fileRoot, root);
        new Thread(ccn).start();
      /* jTree1.setModel(new ModelDirectory(dir));
       jList1.removeAll();
       List<String> _Files = new ArrayList<>();
       
    try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir,"*.{jpg,gif}")) {
        for (Path file: stream) {
        System.out.println(file.getFileName());
            _Files.add(file.getFileName().toString());
        }
        jList1.setListData(_Files.toArray(new String[0]));
        
    } catch (IOException | DirectoryIteratorException x) {
    // IOException can never be thrown by the iteration.
    // In this snippet, it can only be thrown by newDirectoryStream.
    System.err.println(x);
}*/
   }
   private DefaultMutableTreeNode root;
    private DefaultTreeModel treeModel;
    public class CreateChildNodes implements Runnable {

        private DefaultMutableTreeNode root;

        private File fileRoot;

        public CreateChildNodes(File fileRoot, 
                DefaultMutableTreeNode root) {
            this.fileRoot = fileRoot;
            this.root = root;
        }

        @Override
        public void run() {
            createChildren(fileRoot, root);
        }

        private void createChildren(File fileRoot, 
                DefaultMutableTreeNode node) {
            File[] files = fileRoot.listFiles();
            if (files == null) return;

            for (File file : files) {
                DefaultMutableTreeNode childNode = 
                        new DefaultMutableTreeNode(new FileNode(file));
                node.add(childNode);
                if (file.isDirectory()) {
                    createChildren(file, childNode);
                }
            }
        }

    }

    public class FileNode {

        private File file;

        public File getFile() {
            return file;
        }
        public FileNode(File file) {
            this.file = file;
        }

        @Override
        public String toString() {
            String name = file.getName();
            if (name.equals("")) {
                return file.getAbsolutePath();
            } else {
                return name;
            }
        }
    }
    ////////////////////////
   pFileIterator FileIterator = new pFileIterator ();
   private class pFileIterator {
        String m_LastDir;
        int m_PicsPerPage=40;
    void updateDirectoryTree(String Root) {
     
    }   
        
    void updateFileList(String Root, int Page) {
        jList1.removeAll();
       List<String> _Files = new ArrayList<>();
       Path dir = Paths.get(Root);
       //Path dir = Paths.get("D:/furries/andere");
       
    try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir,"*.{jpg,gif,png,bmp}")) {
        for (Path file: stream) {
        System.out.println(file.getFileName());
            _Files.add(file.getFileName().toString());
        }
        jList1.setListData(_Files.toArray(new String[0]));
        
    } catch (IOException | DirectoryIteratorException x) {
    // IOException can never be thrown by the iteration.
    // In this snippet, it can only be thrown by newDirectoryStream.
    System.err.println(x);
    }
    }
    
   }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JComboBox<String> jComboBox1;
    private javax.swing.JList<String> jList1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JTree jTree1;
    // End of variables declaration//GEN-END:variables
}
